/*
 * reboundgen
 * https://github.com/dwallin/reboundgen
 *
 * Copyright (c) 2014 Dave Wallin
 * Licensed under the BSD license.
 */

'use strict';

function extend(target) {
    var sources = [].slice.call(arguments, 1);
    sources.forEach(function (source) {
        for (var prop in source) {
            target[prop] = source[prop];
        }
    });
    return target;
}

exports.generateFromFile = function(filename) {
	if(typeof(filename) !== "string")
	{
		return false;
	}

	console.log("Reading " + filename);
	var jf = require('jsonfile');

	var optionsFile = jf.readFileSync(filename);
	exports.generate(optionsFile);

	return true;
};

exports.generateSingle = function(options) {
	var rebound = require("./rebound");

	// Only transform properties are supported here.
	// And then only translateX-Z, scaleX-Z, rotateX-Z, rotate, skewX, skewY
	// FIXME: add support for left, top, bottom, right, opacity.

	var defaultOptions = {
		name: "anim1",
		steps: 40,
		tension: 30,
		friction: 5,
		initialVelocity: 0,
		hardBounce: false,
		bounceDamp: 0.7,
		properties: {
			translateX: 500,
		},
		outputFolder: "tmp/"
	};

	options = extend( {}, defaultOptions, options);

	var results = { };
	var properties = options.properties;

	var longestSpring = 0;
	var k;

	for (k in properties) {
		// create and run springs for each property



		var friction = options.friction,
			tension = options.tension,
			initialVelocity = options.initialVelocity;

		var startVal = 0;
		var endVal = 0;
		if (typeof(properties[k]) === "object") {

			// Allow overriding of settings on a per property basis
			if (typeof(properties[k].start) === "number")
			{
				startVal = properties[k].start;
			}

			if (typeof(properties[k].end) === "number")
			{
				endVal = properties[k].end;
			}

			if (typeof(properties[k].tension) === "number")
			{
				tension = properties[k].tension;
			}

			if (typeof(properties[k].friction) === "number")
			{
				friction = properties[k].friction;
			}

			if (typeof(properties[k].initialVelocity) === "number")
			{
				initialVelocity = properties[k].initialVelocity;
			}

		} else if (typeof(properties[k]) === "number") {
			endVal = properties[k];
		}


		var looper = new rebound.SimulationLooper();
		var springSystem = new rebound.SpringSystem(looper);
		var spring = springSystem.createSpring(tension, friction);

		var springValues = [];

		spring.addListener({
			onSpringUpdate: function(spring) {
				var val = spring.getCurrentValue();


				if (options.hardBounce && spring.isOvershooting()) {
					spring.setCurrentValue(spring._endValue, true);
					spring.setVelocity(-options.bounceDamp * spring.getVelocity());

					val = 1.0;
				}

				springValues.push(val);
			}
		});

		spring.setValueAndVelocity(startVal, initialVelocity);
		spring.setEndValue(endVal);

		looper.run();


		if (looper.simTime > longestSpring) {
			longestSpring = looper.simTime;
		}

		var resultObj = {
			length: looper.simTime,
			timestep: looper.timestep,
			values: springValues
		};

		results[k] = resultObj;
	}

	var keyframes = {};
	for (var i = 0; i <= 100; i += (100 / options.steps)) {
		var keyframe = {};
		for (k in properties) {
			var val;
			var startVal = 0;
			var endVal = 0;
			if (typeof(properties[k]) === "object") {
				if (typeof(properties[k].start) === "number")
				{
					startVal = properties[k].start;
				}

				if (typeof(properties[k].end) === "number")
				{
					endVal = properties[k].end;
				}

			} else if (typeof(properties[k]) === "number") {
				endVal = properties[k];
			}

			var currentTime = i * longestSpring / 100;
			var ndx = Math.round(currentTime / results[k].timestep);


			if (ndx < results[k].values.length) {
				var springVal;
				springVal = results[k].values[ndx];
				//val = rebound.MathUtil
				//	.mapValueInRange(springVal, 0, 1, startVal, endVal);
				val = springVal;
			} else {
				val = endVal;
			}

			keyframe[k] = val;
		}
		keyframes[i.toFixed(0)] = keyframe;
	}

	// Template it out.

	// Optional?
	var vendorPrefixes = ["-ms-", "-moz-", "-webkit-", ""];
	var output = "";

	var propertyUnits = {
		translateX: "px",
		translateY: "px",
		translateZ: "px",
		scaleX: "",
		scaleY: "",
		scaleZ: "",
		rotate: "deg",
		rotateX: "deg",
		rotateY: "deg",
		rotateZ: "deg",
		skewX: "deg",
		skewY: "deg"
	};

	// FIXME: check to see if this a supported property?

	var p;
	for (p in vendorPrefixes) {
		var prefix = vendorPrefixes[p];
		output += "@" + prefix + "keyframes " + options.name + " {\n";
		for (k in keyframes) {


			// FIXME: first do transform based properties, then do other stuff?
			var keyframe = keyframes[k];
			output += k + "% {\n";
			output += "	transform: ";
			for (var prop in keyframe) {

				output += " " + prop + "(" + keyframe[prop].toFixed(4) + propertyUnits[prop] + ") ";
			}
			output += "; }\n";
		}
		output += "}\n";
	}

	output += "\n// Generated by easegen";
	output += "\n// Recommended Length: " + (longestSpring / 1000) + "\n";

	output += "." + options.name + " {\n ";
	for (p in vendorPrefixes) {
		var prefix = vendorPrefixes[p];
		output += "	" + prefix + "animation: " + options.name + " " + (longestSpring / 1000).toFixed(4) + "s linear 0s;\n";
	}

	output += "}\n";

	//console.log(output);


	var fs = require('fs');
	fs.writeFile(options.outputFolder + "_" + options.name + ".scss", output, function(err) {
		if (err) {
			throw err;
		} else {
			console.log("Generated " + options.name);
		}
	});


	return true;
};


exports.generate = function(options) {
	if (Array.isArray(options)) {
		for (var i = 0; i < options.length; i++) {
			exports.generateSingle(options[i]);
		}
	} else {
		exports.generateSingle(options);
	}

	return true;
};